# Google c++ 规范

在学习cpp语言规范的同时，希望借助typora熟练掌握markdown

然而现在就不会写引言，类似与latex里面的abstract，有些尴尬

规范文件同时阅读英文版和中文版，相互填补缺漏

## 头文件

- #define的保护

  目的是为了防止**多重包含**

  命名格式为 PROJECT_PATH_FILE_H

  例如

  foo/src/bar/baz.h

  则写为

  ```c++
  #ifndef FOO_BAR_BAZ_H
  #define FOO_BAR_BAZ_H
  ...
  #endif // FOO_BAR_BAZ_H
  ```

- 头文件的依赖

  头文件被修改就要重新编译，为了加速编译，使用**前置声明**，尽量减少头文件中`#include`的数量

  头文件需要用到类`File`，但不需要访问其声明，只需前置声明`class File`同时

  - 将数据类型定义为`File *`或是`File &`
  - 参数和返回值为`File`的函数只声明不在头文件中定义
  - 静态成员可以被声明为`File`

  能依赖声明就不要依赖定义

  但是这一点在最新版本的英文文档是截然相反的

  > Avoid using forward declarations where possible. Just `#include` the headers you need

  根据 [ github for google code style ](https://github.com/google/styleguide/tree/gh-pages "go to github") 所知，在规范中列举了前置声明的好处与坏处，好处确实与中文文档所说大致相同，加速了编译，但是会.h文件的依赖项造成致命打击

  > - Forward declarations can hide a dependency, allowing user code to skip necessary recompilation when headers change.
  >
  > - A forward declaration may be broken by subsequent changes to the library. Forward declarations of functions and templates can prevent the header owners from making otherwise-compatible changes to their APIs, such as widening a parameter type, adding a template parameter with a default value, or migrating to a new namespace.
  >
  > - Forward declaring symbols from namespace `std::` yields undefined behavior.
  >
  > - It can be difficult to determine whether a forward declaration or a full `#include` is needed. Replacing an `#include` with a forward declaration can silently change the meaning of code
  >
  >   ```c++
  >   // b.h:
  >   struct B {};
  >   struct D : B {};
  >   
  >   // good_user.cc:
  >   #include "b.h"
  >   void f(B*);
  >   void f(void*);
  >   void test(D* x) { f(x); }  // calls f(B*)
  >         
  >   ```
  >
  >   If the `#include` was replaced with forward decls for B and D, `test()` would call `f(void*)`
  >
  > - Forward declaring multiple symbols from a header can be more verbose than simply `#include`ing the header.
  >
  > - Structuring code to enable forward declarations (e.g. using pointer members instead of object members) can make the code slower and more complex.

- 内联函数

  函数不超过十行且函数体中没有循环和swtich语句，最好将函数定义为内联函数

  虚函数和递归函数就算被声明为内联函数可能实际上也不是内联函数

- -inl.h文件

  简单的内联函数放在.h文件即可，但是对于复杂的内联函数，这样会使.h文件臃肿

  尽管对代码的性能并没有过大影响

  但是为了规范代码，将复杂的内联函数放在-inl.h文件中

  -inl.h还可以用于函数模板的定义

- 函数参数顺序

  先输入后输出

- 头文件包括的顺序

  例如有 class rjp 在pro/src/part01/rjp.cc

  ```c++
  #include part01/rjp.h	//先包含自己所在类的.h文件
  
  #include <sys/types.h>	//C系统文件
  #include <vector>	//C++系统文件
  #include <mutex>
  
  #include <Eigen>	//其他库
  #include part02/r.h	//该项目其他目录的头文件  
  #include part02/j.h	//     /src下
  #include part03/r1.h
  ```





## 作用域

- 命名空间

  一般情况下，记住要把代码放在命名空间里面

